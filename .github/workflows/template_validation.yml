name: Template Validation

# Trigger when a label is added to an issue
on:
  issues:
    types: [labeled]

# Prevent duplicate runs for the same issue
concurrency:
  group: validation-issue-${{ github.event.issue.number }}
  cancel-in-progress: false  # Let first run complete


# Allow workflow to comment on issues and manage labels
permissions:
  issues: write
  contents: write  # Required for repository_dispatch

jobs:
  validate-template:
    runs-on: ubuntu-latest

    steps:
      - name: Validate service request template
        id: validate
        uses: actions/github-script@v7
        with:
          script: |
            // ---- DEBUG LOG ----
            console.log("---- FULL EVENT PAYLOAD ----");
            console.log(JSON.stringify(context.payload, null, 2));
            console.log("---- END PAYLOAD ----");

            // Access the issue data from the GitHub event payload
            const issue = context.payload.issue;
            const issueTitle = issue.title || "";
            const issueBody = issue.body || "";
            const labelName = context.payload.label.name;
            const labels = issue.labels.map(l => l.name);

            console.log("All labels on issue:", labels);
            console.log("Label that triggered this run:", labelName);

            //  Prevent duplicate runs
            // Only process when BOTH labels are present
            const hasType = labels.includes("Type/ServiceRequest");
            const subtype = labels.find(l => l.startsWith("SRType/"));
            
            // Skip if we don't have both labels yet
            if (!hasType || !subtype) {
              if (!hasType && !subtype) {
                console.log("⏭ Neither label present - skipping validation");
              } else if (!hasType) {
                console.log("⏭ Missing Type/ServiceRequest - waiting for it");
              } else if (!subtype) {
                console.log("⏭ Missing SRType label - waiting for it");
              }
              return;
            }
            
            // Check if already validated to prevent duplicate runs
            const { data: existingComments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
            });
            
            const alreadyValidated = existingComments.some(c => 
              c.user.type === "Bot" && 
              (c.body.includes("✅ Template Validation Passed") || 
               c.body.includes("❌ Template Validation Failed"))
            );
            
            if (alreadyValidated) {
              console.log("⏭ Issue already validated - skipping duplicate run");
              return;
            }
            
            console.log("✅ Proceeding with validation - triggered by:", labelName);

            //console.log("✅ Proceeding with validation - triggered by:", labelName);
            
            // At this point, both labels are confirmed to be present
            console.log(`✅ Both labels present. Detected subtype: ${subtype}`);

            // ----------------------
            // Reusable fail function
            // ----------------------
            async function failValidation(message, labelToRemove = labelName) {
              // Remove existing bot comments first to avoid duplicates
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
              });

              for (const c of comments) {
                if (c.user.type === "Bot" && c.body.includes("Template Validation")) {
                  await github.rest.issues.deleteComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: c.id,
                  });
                }
              }

              // Post new failure comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: message,
              });

              // Remove both Type/ServiceRequest and SRType/... labels if present
              const relatedLabels = ["Type/ServiceRequest", ...labels.filter(l => l.startsWith("SRType/"))];

              // Try to remove the incorrect label
              for (const lbl of relatedLabels) {
                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    name: lbl,
                  });
                  console.log(`Removed invalid label: ${lbl}`);
                } catch (err) {
                  console.log(`Could not remove label ${lbl}:`, err.message);
                }
              }

              core.setFailed("Template validation failed");
            }

            // ----------------------
            // Rulesets per SR subtype
            // ----------------------
            const rulesets = {
              "SRType/NormalChange": {
                requiredFields: [
                  "Short Description",
                  "Description",
                  "Priority",
                  "Impact",
                  "Impact Description (Overall)",
                  "Impact Description (Customer)",
                  "Environment Details",
                  "Affected Component",
                  "Affected Services",
                  "Service Outage/Downtime",
                  "Is a maintenance window required or not",
                  "Implementation Plan",
                  "Test Plan",
                  "Monitoring Checks"
                ]
              },
              "SRType/Information": {
                requiredFields: [
                  "Request Description",
                  "Impact",
                  "Customer Project"
                ]
              },
              "SRType/EmergencyChange": {
                requiredFields: [
                  "Short Description",
                  "Description",
                  "Priority",
                  "Impact",
                  "Impact Description",
                  "Customer Project",
                  "Environment Details"
                ],
                allowedValues: {
                  "Priority": ["Critical"]
                }
              }
            };

            // ----------------------
            // Step 2: Check template marker matches subtype
            // ----------------------
            const expectedMarker = `SR ${subtype.replace("SRType/", "")}`;
            if (!issueBody.includes("Template Marker") || !issueBody.includes(expectedMarker)) {
              const comment = `## ❌ Template Validation Failed
              
              The \`${subtype}\` label was added, but this issue was not created using the **${subtype} template**.
              
              The label has been removed. Please recreate the issue using the correct template.`;
              await failValidation(comment, subtype);
              return;
            }

            // ----------------------
            // Step 3: Check title format
            // ----------------------
            if (!issueTitle.startsWith("[SR-Change]:")) {
              const comment = `## ❌ Template Validation Failed
              
              The issue title must start with \`[SR-Change]:\`.
              
              The label has been removed. Please recreate the issue using the ${subtype} template.`;
              await failValidation(comment, subtype);
              return;
            }

            // ----------------------
            // Step 4: Validate required fields
            // ----------------------
            const rules = rulesets[subtype];
            const issueBodyLower = issueBody.toLowerCase();
            const missingFields = rules.requiredFields.filter(f => !issueBodyLower.includes(f.toLowerCase()));

            if (missingFields.length > 0) {
              const comment = `## ❌ Template Validation Failed
              
              **Missing Required Fields for ${subtype}:**
              ${missingFields.map(f => `- ${f}`).join("\n")}
              
              The label has been removed. Please complete all required fields using the ${subtype} template.`;
              await failValidation(comment, subtype);
              return;
            }

            // ----------------------
            // Step 5: Validate allowed values (if defined)
            // ----------------------
            if (rules.allowedValues) {
              for (const [field, allowed] of Object.entries(rules.allowedValues)) {
                if (!allowed.some(val => issueBody.includes(val))) {
                  const comment = `## ❌ Template Validation Failed
                  
                  Field **${field}** must contain one of: ${allowed.join(", ")}
                  
                  The label has been removed. Please correct the values using the ${subtype} template.`;
                  await failValidation(comment, subtype);
                  return;
                }
              }
            }

            // ----------------------
            // Step 6: Passed all checks - Add validation-passed label
            // ----------------------
            // Remove duplicate comment deletion (already done in failValidation)
            // Only delete old comments here since we passed validation
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
            });

            for (const c of comments) {
              if (c.user.type === "Bot" && c.body.includes("Template Validation")) {
                await github.rest.issues.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: c.id,
                });
              }
            }

            // Add validation-passed label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: ['validation-passed']
            });

            const comment = `## ✅ Template Validation Passed
              
            All required checks succeeded for **${subtype}**.
            The ServiceNow case will be created automatically.`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: comment
            });

            // Set output for next workflow
            core.setOutput('issue_number', issue.number.toString());
            core.setOutput('validation_passed', 'true');


      # Trigger ServiceNow workflow with specific issue number
      - name: Trigger ServiceNow Integration
        if: steps.validate.outputs.validation_passed == 'true'  #  Now correctly references step ID
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = '${{ steps.validate.outputs.issue_number }}';
            
            console.log(`Triggering ServiceNow workflow for issue #${issue_number}`);
            
            // Trigger repository dispatch event with issue number
            await github.rest.repos.createDispatchEvent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              event_type: 'validation-passed',
              client_payload: {
                issue_number: parseInt(issue_number)
              }
            });
            
            console.log('✅ ServiceNow workflow triggered');