name: Template Validation

# Trigger when a label is added to an issue
on:
  issues:
    types: [labeled]

# Prevent duplicate runs for the same issue
concurrency:
  group: validation-issue-${{ github.event.issue.number }}
  cancel-in-progress: false

permissions:
  issues: write
  contents: write

jobs:
  validate-template:
    runs-on: ubuntu-latest

    steps:
      - name: Validate service request template
        id: validate
        uses: actions/github-script@v7
        with:
          script: |
            // ---- DEBUG LOG ----
            console.log("---- FULL EVENT PAYLOAD ----");
            console.log(JSON.stringify(context.payload, null, 2));
            console.log("---- END PAYLOAD ----");

            const issue = context.payload.issue;
            const issueTitle = issue.title || "";
            const issueBody = issue.body || "";
            const labelName = context.payload.label.name;
            const labels = issue.labels.map(l => l.name);

            console.log("All labels on issue:", labels);
            console.log("Label that triggered this run:", labelName);

            //Dynamically find SRType and catalog labels
            const srTypeLabel = labels.find(l => l.startsWith("SRType/"));
          
            const catalogLabel = labels.find(l => l.startsWith("CatalogueItem/"));
            
            // ----------------------
            // Check if this is a Service Request template
            // ----------------------
            const validMarkers = [
              "SR Generic",
              "SR Request Logs",
              "SR Standard Generic",
              "SR Information"
            ];

            const hasValidMarker = validMarkers.some(marker => issueBody.includes(marker));

            // If no SR template marker, check if they're trying to add SR labels to wrong template
            if (!hasValidMarker) {
              // Check if they added SRType/ or CatalogueItem/ labels to a non-SR template
              if (srTypeLabel || catalogLabel) {
                console.log("SR labels added to non-SR template - posting warning");
                
                // Check if we already posted this warning
                const { data: existingComments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                });
                
                const hasWarningComment = existingComments.some(c => 
                  c.user.type === "Bot" && 
                  c.body.includes("❌ Template Validation Failed") &&
                  c.body.includes("Invalid Template for Service Request Labels")
                );
                
                // Only post warning if we haven't already
                if (!hasWarningComment) {
                  let labelsToRemove = [];
                  if (srTypeLabel) labelsToRemove.push(srTypeLabel);
                  if (catalogLabel) labelsToRemove.push(catalogLabel);
                  
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `## ❌ Template Validation Failed

            **Invalid Template for Service Request Labels.**

            Cannot use **SRType/** or **CatalogueItem/** labels on this issue because it was not created using a Service Request template.

            These labels have been removed. If need to create a Service Request, please use one of the official Service Request templates.`
                  });
                  
                  // Remove the  SR labels from non SR template
                  for (const lbl of labelsToRemove) {
                    try {
                      await github.rest.issues.removeLabel({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issue.number,
                        name: lbl,
                      });
                      console.log(`Removed invalid label from non-SR template: ${lbl}`);
                    } catch (err) {
                      console.log(`Could not remove label ${lbl}:`, err.message);
                    }
                  }
                }
              } else {
                console.log("⏭️ Not a Service Request template and no SR labels - skipping validation");
              }
              
              return;
            }

            console.log("✅ Service Request template detected - proceeding with validation");

            // Skip if we don't have both labels yet
            if (!srTypeLabel || !catalogLabel) {
              let failureMessage = "";
              
              if (!srTypeLabel && !catalogLabel) {
                console.log("Neither label present - skipping validation");
                failureMessage = `## ❌ Template Validation Failed

            **Missing Required Labels:**

            Please add both required labels:
            - **SRType/** label (e.g., \`SRType/Normal Change\`, \`SRType/Emergency Change\`)
            - **CatalogueItem/** label (e.g., \`CatalogueItem/Generic Requests\`)`;
              } else if (!srTypeLabel) {
                console.log("Missing SRType/ label - waiting for it");
                failureMessage = `## ❌ Template Validation Failed

            **Missing SRType Label:**

            You've added: **${catalogLabel}**

            Please also add an **SRType/** label (e.g., \`SRType/Normal Change\`)`;
              } else if (!catalogLabel) {
                console.log("Missing CatalogueItem/ label - waiting for it");
                failureMessage = `## ❌ Template Validation Failed

            **Missing CatalogueItem Label:**

            You've added: **${srTypeLabel}**

            Please also add a **CatalogueItem/** label (e.g., \`CatalogueItem/Generic Requests\`)

            Validation will run automatically once both labels are added.`;
              }
              
              // Check if we already posted this type of failure message
              const { data: existingComments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
              });
              
              const hasFailureComment = existingComments.some(c => 
                c.user.type === "Bot" && 
                c.body.includes("❌ Template Validation Failed") &&
                (c.body.includes("Missing Required Labels") || 
                c.body.includes("Missing SRType Label") || 
                c.body.includes("Missing CatalogueItem Label"))
              );
              
              // Only post if we haven't already
              if (!hasFailureComment) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: failureMessage
                });
              }
              
              return;
            }

            // When both labels are present, delete the missing label failure comment
            const { data: existingComments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
            });

            for (const c of existingComments) {
              if (c.user.type === "Bot" && 
                  c.body.includes("❌ Template Validation Failed") &&
                  (c.body.includes("Missing Required Labels") || 
                  c.body.includes("Missing SRType Label") || 
                  c.body.includes("Missing CatalogueItem Label"))) {
                await github.rest.issues.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: c.id,
                });
              }
            }

            // Check if already validated to prevent duplicate runs
            const { data: existingComments2 } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
            });
            
            const alreadyValidated = existingComments2.some(c => 
              c.user.type === "Bot" && 
              (c.body.includes("✅ Template Validation Passed") || 
               c.body.includes("❌ Template Validation Failed"))
            );
            
            if (alreadyValidated) {
              console.log(" Issue already validated - skipping duplicate run");
              return;
            }
            
            console.log("✅ Proceeding with validation - triggered by:", labelName);
            console.log(`✅ Both labels present. SRType: ${srTypeLabel}, Catalog: ${catalogLabel}`);

            
            // Extract values dynamically from labels
            // Extract SR Type (Ex: "SRType/Normal Change" -> "Normal Change")
            const srType = srTypeLabel.replace("SRType/", "");
            
            // Extract case type (always "Service Request" if SRType label exists)
            const caseType = "Service Request";
            
            // Extract catalog item (Ex: " CatalogueItem/Generic Requests" -> "Generic Requests")
            const catalogItem = catalogLabel.replace("CatalogueItem/", "");
            
            console.log(`Extracted SR Type: ${srType}`);
            console.log(`Extracted Case Type: ${caseType}`);
            console.log(`Extracted Catalog Item: ${catalogItem}`);

            // ----------------------
            // Reusable fail function
            // ----------------------
            async function failValidation(message) {
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
              });

              for (const c of comments) {
                if (c.user.type === "Bot" && c.body.includes("Template Validation")) {
                  await github.rest.issues.deleteComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: c.id,
                  });
                }
              }

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: message,
              });

              // Remove both SRType/ and catalog labels
              const relatedLabels = [
                ...labels.filter(l => l.startsWith("SRType/")),
                ...labels.filter(l => l.startsWith("CatalogueItem/"))
              ];

              for (const lbl of relatedLabels) {
                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    name: lbl,
                  });
                  console.log(`Removed invalid label: ${lbl}`);
                } catch (err) {
                  console.log(`Could not remove label ${lbl}:`, err.message);
                }
              }

              core.setFailed("Template validation failed");
            }

            // ----------------------
            // Rulesets based on full catalog label
            // ----------------------
            const rulesets = {
              // Normal Change templates
              "CatalogueItem/Generic Requests": {
                requiredFields: [
                  "Short Description",
                  "Description",
                  "Priority",
                  "Impact",
                  "Impact Description (Overall)",
                  "Impact Description (Customer)",
                  "Environment Details",
                  "Affected Component",
                  "Affected Services",
                  "Service Outage/Downtime",
                  "Is a maintenance window required or not",
                  "Implementation Plan",
                  "Test Plan",
                  "Monitoring Checks"
                ]
              },
              
              // Emergency Change templates
              "CatalogueItem/Request Logs": {
                requiredFields: [
                  "Short Description",
                  "Description",
                  "Priority",
                  "Impact",
                  "Impact Description",
                  "Customer Project",
                  "Environment Details"
                ],
                allowedValues: {
                  "Priority": ["Critical"]
                }
              },
              
              // Standard Change templates
              "CatalogueItem/Standard Generic": {
                requiredFields: [
                  "Short Description",
                  "Description",
                  "Priority",
                  "Impact",
                  "Environment Details"
                ]
              },
              
              // Add more catalog combinations as needed
              "CatalogueItem/Information": {
                requiredFields: [
                  "Request Description",
                  "Impact",
                  "Customer Project"
                ]
              }
            };

            
            // Step 3: Check title format
          
            if (!issueTitle.startsWith("[SR-Change]:")) {
              const comment = `## ❌ Template Validation Failed
              
              The issue title must start with \`[SR-Change]:\`.
              
              The labels have been removed. Please recreate the issue using the ${catalogLabel} template.`;
              await failValidation(comment);
              return;
            }

             
            // Step 4: Validate required fields using catalog label
             
            const rules = rulesets[catalogLabel];
            
            if (!rules) {
              const comment = `## ❌ Template Validation Failed
              
              Unknown catalog type: **${catalogLabel}**
              
              **Available catalog types:**
              ${Object.keys(rulesets).map(k => `- ${k}`).join("\n")}
              
              The labels have been removed. Please use a valid template.`;
              await failValidation(comment);
              return;
            }
            
            const issueBodyLower = issueBody.toLowerCase();
            const missingFields = rules.requiredFields.filter(f => !issueBodyLower.includes(f.toLowerCase()));

            if (missingFields.length > 0) {
              const comment = `## ❌ Template Validation Failed
              
              **Missing Required Fields for ${catalogLabel}:**
              ${missingFields.map(f => `- ${f}`).join("\n")}
              
              The labels have been removed. Please complete all required fields using the ${catalogLabel} template.`;
              await failValidation(comment);
              return;
            }

            // ----------------------
            // Step 5: Passed all checks
            // ----------------------
            //Get all existing comments on the github issue
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
            });

            //Loop through all comments and delete any old bot comments about "Template Validation"
            for (const c of comments) {
              if (c.user.type === "Bot" && c.body.includes("Template Validation")) {
                await github.rest.issues.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: c.id,
                });
              }
            }

            // Add "validation-passed" label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: ['validation-passed']
            });

            // Post success comment with extracted values
            const comment = `## ✅ Template Validation Passed
              
            All required checks succeeded for **${catalogLabel}**.
            
            The ServiceNow case will be created automatically.`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: comment
            });

            core.setOutput('issue_number', issue.number.toString());
            core.setOutput('validation_passed', 'true');
            core.setOutput('sr_type', srType);
            core.setOutput('case_type', caseType);
            core.setOutput('catalog_item', catalogItem);


      # Trigger ServiceNow workflow
      - name: Trigger ServiceNow Integration
        if: steps.validate.outputs.validation_passed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = '${{ steps.validate.outputs.issue_number }}';
            const sr_type = '${{ steps.validate.outputs.sr_type }}';
            const case_type = '${{ steps.validate.outputs.case_type }}';
            const catalog_item = '${{ steps.validate.outputs.catalog_item }}';
            const catalog_prefix = '${{ steps.validate.outputs.catalog_prefix }}';
            
            console.log(`Triggering ServiceNow workflow for issue #${issue_number}`);
            console.log(`SR Type: ${sr_type}`);
            console.log(`Case Type: ${case_type}`);
            console.log(`Catalog Item: ${catalog_item}`);
            console.log(`Catalog Prefix: ${catalog_prefix}`);
            
            await github.rest.repos.createDispatchEvent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              event_type: 'validation-passed',
              client_payload: {
                issue_number: parseInt(issue_number),
                sr_type: sr_type,
                case_type: case_type,
                catalog_item: catalog_item,
                catalog_prefix: catalog_prefix
              }
            });
            
            console.log('✅ ServiceNow workflow triggered');