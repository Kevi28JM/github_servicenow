name: ServiceNow Integration  

on:
  repository_dispatch:
    types: [validation-passed]  # Triggered directly by validation workflow

#Prevents multiple concurrent runs for the same issue
concurrency:
     group: servicenow-issue-${{ github.event.client_payload.issue_number }} 
     cancel-in-progress: false #Won't cancel a running job if a new one starts

permissions:
  issues: write
  contents: read

env:
  SERVICENOW_PRODUCT: "WSO2 API Manager 1.10.0 Developer Portal"
  SERVICENOW_PROJECT: "Customer Portal Customer Project1 - Subscription"
  # ServiceNow URL stored in GitHub Secrets
  SERVICENOW_URL: ${{ secrets.SERVICENOW_URL }}
  SERVICENOW_UI_URL: ${{ secrets.SERVICENOW_UI_URL }} 

jobs:
  send-to-servicenow:
    runs-on: ubuntu-latest
    steps:

      - name: Get Issue Number from Payload
        id: get_issue
        uses: actions/github-script@v7
        with:
          script: |
            console.log('=== DEBUG: Repository Dispatch Payload ===');
            console.log(JSON.stringify(context.payload, null, 2));
            
            // Get issue number directly from the dispatch event payload
            const issue_number = context.payload.client_payload.issue_number;
            
            if (!issue_number) {
              core.setFailed('❌ No issue number in payload');
              return;
            }
            
            console.log(`✅ Got issue number from dispatch: #${issue_number}`);
            
            core.setOutput('issue_number', issue_number.toString());
            core.setOutput('found', 'true');

      
      - name: Get Issue Details
        id: get_issue_details
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = '${{ steps.get_issue.outputs.issue_number }}'; //Gets the issue number from the previous step
            
            
            const { data: issue } = await github.rest.issues.get({ //Calls github API to fetch issue details
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(issue_number)
            });
            
            // Check if validation-passed label exists
            const hasValidationPassed = issue.labels.some(l => l.name === 'validation-passed');
            
            if (!hasValidationPassed) {
              console.log('Issue does not have validation-passed label, skipping');
              core.setOutput('should_process', 'false');
              return;
            }

            // Check if already processed to prevent duplicates
            const { data: comments } = await github.rest.issues.listComments({ //fetch all comments on the issue
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(issue_number)
            });

            const alreadyProcessed = comments.some(c => //Checks if any comment matches
              c.user.type === 'Bot' && 
              c.body.includes('ServiceNow Case Created Successfully')
            );

            if (alreadyProcessed) {
              console.log('Issue already processed - ServiceNow case already created');
              core.setOutput('should_process', 'false');
              return;
            }
            
            //Saves each piece of issue info for later steps
            core.setOutput('should_process', 'true');
            core.setOutput('issue_body', issue.body || '');
            core.setOutput('issue_title', issue.title || '');
            core.setOutput('issue_url', issue.html_url || '');
            core.setOutput('github_user', issue.user.login || '');
            core.setOutput('labels', issue.labels.map(l => l.name).join(', '));

            
      - name: Extract All Fields Dynamically
        if: steps.get_issue_details.outputs.should_process == 'true' //Only runs if previous step set should_process to 'true'
     
        id: extract_fields
        uses: actions/github-script@v7
        with:
          script: |
            const body = `${{ steps.get_issue_details.outputs.issue_body }}`; //Gets the issue description text
            
            console.log('Fully dynamic field extractor');
            console.log('Issue body length:', body.length);
            
            // EXTRACT ALL FIELDS AUTOMATICALLY
             
            //Defines a function to parse the issue body and extract fields
            function extractAllFields(body) {
              const fields = {};
              
              // Regex to match: ### FieldName\n\nValue
              const regex = /###\s+([^\n]+)\s*\n+([^\n][\s\S]*?)(?=\n+###|\n*$)/g;
              
              let match;
              let count = 0;
              
              //Finds all matches in the text, one at a time
              while ((match = regex.exec(body)) !== null) { //Finds next match continues until no more matches

                const label = match[1].trim(); //First captured group (field name)
                const value = match[2].trim(); //Second captured group (field value)
                
                // Skip empty or "No response" values
                if (!value || value === '_No response_' || value === 'No response') {
                  console.log(`⊗ Skipping empty: ${label}`);
                  continue;
                }
                
                // Convert label to field ID ,converts field name to lowercase for easier comparison
                const normalizedLabel = label.toLowerCase();
                
                // Known field mappings for metadata
                // Maps labels to servicenow field IDs
                const knownFields = {
                  'template marker': 'template_marker',
                  'servicenow catalog item': 'catalog_item',
                  'catalog item': 'catalog_item',
                  'case type': 'case_type',
                  'priority': 'priority',
                  'severity': 'priority',
                  'short description': 'u_short_description',
                  'description': 'description',
                  'detailed description': 'description',
                  'impact': 'u_impact',
                  'impact description (overall)': 'u_impact_description_overall',
                  'impact description (customer)': 'u_impact_description_customer',
                  'environment details': 'u_project_environment',
                  'environment': 'u_project_environment',
                  'affected component': 'u_affected_component',
                  'affected services': 'u_affected_services',
                  'service outage/downtime': 'u_service_outage',
                  'is a maintenance window required or not': 'u_maintenance_window',
                  'maintenance window': 'u_maintenance_window',
                  'implementation plan': 'u_implementation_plan',
                  'test plan': 'u_test_plan',
                  'monitoring checks': 'u_monitoring_checks',
                  'request details': 'u_request_details'
                };
                
                let fieldId;
                
                if (knownFields[normalizedLabel]) {
                  // Use known mapping
                  fieldId = knownFields[normalizedLabel];
                  console.log(`✓ [${++count}] "${label}" → ${fieldId} (mapped)`);
                } else {
                  // Auto-generate field ID with u_ prefix (For unknown labels it auto-generates a ServiceNow-style field name (prefix u_ and convert spaces to underscores)
                  fieldId = 'u_' + label
                    .replace(/[^\w\s-]/g, '')  // Remove special chars
                    .trim()
                    .toLowerCase()
                    .replace(/\s+/g, '_')      // Spaces to underscores
                    .replace(/^u_+/, '');      // Remove duplicate u_
                  
                  console.log(`✓ [${++count}] "${label}" → ${fieldId} (auto-generated)`);
                }
                
                fields[fieldId] = value;
              }
              
              return fields;
            }
            //allFields is that resulting object where keys are ServiceNow field IDs and values are extracted from the issue body
            const allFields = extractAllFields(body);
            
            console.log(`\n Extracted ${Object.keys(allFields).length} fields`);
            
            console.log('ALL FIELDS:');
            console.log(JSON.stringify(allFields, null, 2));
             
             
            // IDENTIFY CONTROL FIELDS

            const catalogItem = allFields.servicenow_catalog_item || 
                               allFields.catalog_item || 
                               'General Requests';
            
            const caseType = allFields.case_type || 'Service Request';
            const priority = allFields.priority || 'Moderate';
            const environment = allFields.u_project_environment || 'Development';
            
            
            // MAP PRIORITY 

            const priorityMap = {
              'Critical': '1 - Critical',
              'High': '2 - High',
              'Moderate': '3 - Moderate',
              'Low': '4 - Low'
            };
            
            const mappedPriority = priorityMap[priority] || '3 - Moderate';
            allFields.priority = mappedPriority;
            
            console.log('  Mapped Priority:', mappedPriority);
            
            
            // PARSE ENVIRONMENTS (if multiple)
             
            if (environment) {
              const parsedEnv = environment
                .split(',')
                .map(e => e.trim())
                .filter(e => e.length > 0)
                .join(', ');
              
              allFields.u_project_environment = parsedEnv;
              console.log('  Parsed Environment:', parsedEnv);
            }
            
             
            // SET OUTPUTS
             
            core.setOutput('all_fields', JSON.stringify(allFields));
            core.setOutput('catalog_item', catalogItem);
            core.setOutput('case_type', caseType);
            core.setOutput('priority', mappedPriority);
            core.setOutput('environment', environment);
            
            console.log('\n✅ Dynamic extraction complete!');
            


      - name: Build Dynamic Payload
        if: steps.get_issue_details.outputs.should_process == 'true'
        id: build_payload
        run: |
          echo "Building fully dynamic payload..."
          
          # Create a final JSON payload file that will be sent to ServiceNow
          # Get all extracted fields
          ALL_FIELDS='${{ steps.extract_fields.outputs.all_fields }}'
          
          # Get gitHub metadata
          ISSUE_NUMBER="${{ steps.get_issue.outputs.issue_number }}"
          ISSUE_TITLE='${{ steps.get_issue_details.outputs.issue_title }}'
          ISSUE_URL="${{ steps.get_issue_details.outputs.issue_url }}"
          GITHUB_USER="${{ steps.get_issue_details.outputs.github_user }}"
          REPO_FULL_NAME="${{ github.repository }}"
          LABELS="${{ steps.get_issue_details.outputs.labels }}"
          
          # Environment variables
          PRODUCT="${{ env.SERVICENOW_PRODUCT }}"
          PROJECT="${{ env.SERVICENOW_PROJECT }}"
          
          echo " Payload Summary:"
          echo "  ├─ Catalog: ${{ steps.extract_fields.outputs.catalog_item }}"
          echo "  ├─ Case Type: ${{ steps.extract_fields.outputs.case_type }}"
          echo "  ├─ Priority: ${{ steps.extract_fields.outputs.priority }}"
          echo "  ├─ Environment: ${{ steps.extract_fields.outputs.environment }}"
          echo "  ├─ Fields: $(echo "$ALL_FIELDS" | jq 'length') total"
          echo "  ├─ Project: $PROJECT"
          echo "  └─ Product: $PRODUCT"
          
          # Create a simple HTML formatted description  
          FORMATTED_DESCRIPTION=$(echo "$ALL_FIELDS" | jq -r '
            (to_entries | map(
              "<strong>" + (.key | gsub("^u_"; "") | gsub("_"; " ") | ascii_upcase) + ":</strong><br/>" +
              (.value | gsub("\n"; "<br/>")) + "<br/><br/>"
            ) | join("")) +
            "<br/><strong>────────────────────────────────────────────────────────────</strong><br/>"
          ')
          
          # Merge all fields with GitHub metadata + formatted description
          PAYLOAD=$(echo "$ALL_FIELDS" | jq \
            --arg project "$PROJECT" \
            --arg product "$PRODUCT" \
            --arg title "$ISSUE_TITLE" \
            --arg issue_number "$ISSUE_NUMBER" \
            --arg issue_url "$ISSUE_URL" \
            --arg github_user "$GITHUB_USER" \
            --arg repository_full_name "$REPO_FULL_NAME" \
            --arg labels "$LABELS" \
            --arg formatted_description "$FORMATTED_DESCRIPTION" \
            '. + {
              project: $project,
              product: $product,
              title: $title,
              issue_number: $issue_number,
              issue_url: $issue_url,
              u_github_issue_url: $issue_url,
              github_user: $github_user,
              repository_full_name: $repository_full_name,
              labels: $labels,
              description: $formatted_description
            }')
          
          echo "$PAYLOAD" > payload.json
          
          echo ""
          echo " Final Payload:"
          cat payload.json | jq '.'
          echo ""
          echo "✅ Dynamic payload built successfully"


      #  Enhanced Send to ServiceNow with Authentication
      - name: Send to ServiceNow
        if: steps.get_issue_details.outputs.should_process == 'true'
        id: send_servicenow
        run: |
          # POST the payload to ServiceNow API and capture the response

          # Reads servicenow URL and credentials from secrets (never hardcoded)
          SERVICENOW_URL="${{ secrets.SERVICENOW_URL }}"
          
          # for API calls from GitHub Actions
          #user must have proper permissions to access the ServiceNow API and create cases 
          SERVICENOW_USERNAME="${{ secrets.SERVICENOW_USERNAME }}"
          SERVICENOW_PASSWORD="${{ secrets.SERVICENOW_PASSWORD }}"
          
           
          
          echo "Sending to ServiceNow (URL hidden for security)"
          echo ""
          
          # Using Basic Authentication with credentials from secrets
          #Uses curl to POST payload.json to the ServiceNow endpoint, saving the body to response.json and capturing HTTP status in HTTP_CODE
          HTTP_CODE=$(curl -X POST \
            -H "Content-Type: application/json" \
            -H "User-Agent: GitHub-Actions-WSO2/1.0" \
            -u "${SERVICENOW_USERNAME}:${SERVICENOW_PASSWORD}" \
            -d @payload.json \
            -w "%{http_code}" \
            -o response.json \
            -s \
            "$SERVICENOW_URL")
          
          # If using API Key instead of Basic Auth
          # HTTP_CODE=$(curl -X POST \
          #   -H "Content-Type: application/json" \
          #   -H "Authorization: Bearer ${SERVICENOW_API_KEY}" \
          #   -H "User-Agent: GitHub-Actions-WSO2/1.0" \
          #   -d @payload.json \
          #   -w "%{http_code}" \
          #   -o response.json \
          #   -s \
          #   "$SERVICENOW_URL")
          
          echo "HTTP Status: $HTTP_CODE"
          echo ""
          echo "ServiceNow Response:"
          cat response.json | jq '.' || cat response.json
          echo ""
          
          if [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "200" ]; then
            echo "✅ Successfully created case in ServiceNow"
            
            # Extract case number and sys_id from response
            CASE_NUMBER=$(cat response.json | jq -r '.result.case_number // .case_number // empty')
            CASE_SYS_ID=$(cat response.json | jq -r '.result.sys_id // .result.case_sys_id // .case_sys_id // .sys_id // empty')
            
            echo "case_number=$CASE_NUMBER" >> $GITHUB_OUTPUT
            echo "case_sys_id=$CASE_SYS_ID" >> $GITHUB_OUTPUT
            
            if [ -n "$CASE_NUMBER" ]; then
              echo " Case Number: $CASE_NUMBER"
            fi
            if [ -n "$CASE_SYS_ID" ]; then
              echo " Case Sys ID: $CASE_SYS_ID"
            fi
            
            exit 0
          else
            echo "❌ Failed to create case (HTTP $HTTP_CODE)"
            exit 1
          fi

     
      # Query Change Requests Linked to This Case
       
      - name: Debug - Check Case Info
        if: success()
        run: |
          #Print the case info and whole response
          echo "=== DEBUG: Checking Case Information ==="
          echo "Case Number: ${{ steps.send_servicenow.outputs.case_number }}"
          echo "Case Sys ID: ${{ steps.send_servicenow.outputs.case_sys_id }}"
          echo ""
          echo "Full response.json:"
          cat response.json | jq '.'
          echo ""

          #confirm extraction of sys_id
          echo "Attempting to extract sys_id..."
          cat response.json | jq -r '.result.sys_id // .sys_id // .result.case_sys_id // .case_sys_id // "NOT_FOUND"'
      
      #Find any Change Requests (CRs) linked to the created case and format them for a GitHub comment
      - name: Query Change Requests for Case
        if: success() && steps.send_servicenow.outputs.case_number != ''
        id: query_crs
        run: |
          #reads case number and sys_id from previous step
          CASE_NUMBER="${{ steps.send_servicenow.outputs.case_number }}"
          CASE_SYS_ID="${{ steps.send_servicenow.outputs.case_sys_id }}"
          
          # Builds a ServiceNow base URL from the REST URL secret  
          SERVICENOW_CUSTOM_URL="${{ secrets.SERVICENOW_URL }}"
          SERVICENOW_BASE_URL=$(echo "$SERVICENOW_CUSTOM_URL" | sed 's|/api/.*||')
          
          SERVICENOW_USERNAME="${{ secrets.SERVICENOW_USERNAME }}"
          SERVICENOW_PASSWORD="${{ secrets.SERVICENOW_PASSWORD }}"
          SERVICENOW_UI_URL="${{ secrets.SERVICENOW_UI_URL }}"
          
          echo "  Querying Change Requests for Case"
          echo "   Case Number: ${CASE_NUMBER}"
          echo "   Case Sys ID: ${CASE_SYS_ID}"
          
          # Validate required variables
          if [ -z "$CASE_SYS_ID" ] || [ "$CASE_SYS_ID" = "null" ]; then
            echo " Case sys_id not available, cannot query CRs"
            echo "cr_count=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Add delay to avoid rate limiting
          sleep 2
          
          # Query the TASK table with sys_class_name filter
           
          #Builds a query URL to the ServiceNow endpoint to get all change requests linked to the case
          QUERY_URL="${SERVICENOW_BASE_URL}/api/now/table/task?sysparm_query=parent=${CASE_SYS_ID}^sys_class_name=change_request&sysparm_fields=number,state,sys_id&sysparm_display_value=true&sysparm_limit=50"
          
          echo "   Querying task table for change requests..."
          
          # Execute curl to get CRs, capture HTTP status
          HTTP_CODE=$(curl -s -w "%{http_code}" \
            -u "${SERVICENOW_USERNAME}:${SERVICENOW_PASSWORD}" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            -H "User-Agent: GitHub-Actions-WSO2/1.0" \
            -o crs.json \
            "$QUERY_URL")
          
          echo "   HTTP Response Code: $HTTP_CODE"
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "  Unable to query CRs (HTTP $HTTP_CODE)"
            echo "   Response:"
            cat crs.json 2>/dev/null || echo "No response"
            echo ""Extract base URL from custom REST API URL
            echo "cr_count=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check if we got valid JSON
          if ! cat crs.json | jq empty 2>/dev/null; then
            echo "❌ Invalid JSON response"
            cat crs.json
            echo "cr_count=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Parse CR results
          CR_COUNT=$(cat crs.json | jq -r '.result | length' 2>/dev/null || echo "0")
          
          if ! [[ "$CR_COUNT" =~ ^[0-9]+$ ]]; then
            echo "  Invalid CR count: $CR_COUNT"
            echo "   Full response:"
            cat crs.json | jq '.'
            CR_COUNT=0
          fi
          
          echo "✅ Found $CR_COUNT Change Request(s)"
          
          if [ "$CR_COUNT" -gt 0 ]; then
            echo ""
            echo "Change Requests:"
            cat crs.json | jq -r '.result[] | "  - \(.number): \(.state // "Unknown")"'
            
           # Format CR list: [CHG0038282](url) - New
            CR_LIST=$(cat crs.json | jq -r --arg base_url "$SERVICENOW_UI_URL" '
              .result[] | 
              "- [**" + .number + "**](" + $base_url + "/now/nav/ui/classic/params/target/change_request.do?sys_id=" + .sys_id + "&sysparm_view=Change_Request) - " + (.state // "Unknown")
            ' 2>/dev/null || echo "- Error formatting CR list")
            
            echo "cr_count=$CR_COUNT" >> $GITHUB_OUTPUT
            echo "cr_list<<EOF" >> $GITHUB_OUTPUT
            echo "$CR_LIST" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            
            echo ""
            echo "Formatted list for GitHub comment:"
            echo "$CR_LIST"
          else
            echo "   No CRs linked to this case yet"
            echo "cr_count=0" >> $GITHUB_OUTPUT
          fi

      #Post a comment on the GitHub issue to say the ServiceNow case was created and include details
      - name: Comment on Issue - Success
        if: success() && steps.get_issue_details.outputs.should_process == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            # Read the response.json file to get case details
            const fs = require('fs');
            let response = {};
            
            # Parse the response.json to extract case details
            try {
              response = JSON.parse(fs.readFileSync('response.json', 'utf8'));
              if (response.result) response = response.result;
            } catch (e) {
              console.log('Could not read response:', e);
            }
            
            # Extract case details
            const caseNumber = response.case_number || 'Unknown';
            const caseSysId = response.case_sys_id || response.sys_id || '';  // Get sys_id   
            const catalogItem = '${{ steps.extract_fields.outputs.catalog_item }}';
            const caseType = '${{ steps.extract_fields.outputs.case_type }}';
            const priority = '${{ steps.extract_fields.outputs.priority }}';
            const environment = '${{ steps.extract_fields.outputs.environment }}';   

            # Read the JSON string of all extracted fields, parse it into an object. If parsing fails, keep an empty object and log the error
            const allFieldsStr = '${{ steps.extract_fields.outputs.all_fields }}';
            let allFields = {};
            try {
              allFields = JSON.parse(allFieldsStr);
            } catch (e) {
              console.log('Parse error:', e);
            }
            
            const fieldCount = Object.keys(allFields).length;
            const issue_number = '${{ steps.get_issue.outputs.issue_number }}';

             
            // Build ServiceNow case URL 
            servicenowBaseUrl = '${{ secrets.SERVICENOW_UI_URL }}';
            const caseUrl = caseSysId 
              ? `${servicenowBaseUrl}/now/nav/ui/classic/params/target/sn_customerservice_case.do?sys_id=${caseSysId}&sysparm_view=wso2_cs_generic`
              : null;
            
            //  Make case number clickable
            const caseNumberDisplay = caseUrl 
              ? `[${caseNumber}](${caseUrl})` 
              : `\`${caseNumber}\``;
            
              //  Add CR information
            const crCount = '${{ steps.query_crs.outputs.cr_count }}' || '0';
            const crList = `${{ steps.query_crs.outputs.cr_list }}` || '';
            
            let crSection = '';
            if (parseInt(crCount) > 0) {
              crSection = `

            ### Associated Change Requests (${crCount})
            ${crList}
            `;
            } else {
              crSection = `

            ### Associated Change Requests
            *No change requests linked to this case yet.*
            `;
            }
            
            const commentBody = `## ✅ ServiceNow Case Created Successfully

            **Case Number:** ${caseNumberDisplay}
            ${crSection}

            ### Request Details
            - **Catalog:** ${catalogItem}
            - **Type:** ${caseType}
            - **Priority:** ${priority}
            - **Environment:** ${environment}
             

            ### Auto-Mapped
            - **Project:** ${{ env.SERVICENOW_PROJECT }}
            - **Product:** ${{ env.SERVICENOW_PRODUCT }}

            ---
            *All ${fieldCount} fields from your template were automatically extracted and submitted to ServiceNow.*

            *Automated via GitHub Actions*`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(issue_number),
              body: commentBody
            });

      #If the workflow failed to create a case, post a failure comment with basic debug info
      - name: Comment on Issue - Failure
        if: failure() && steps.get_issue_details.outputs.should_process == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const catalogItem = '${{ steps.extract_fields.outputs.catalog_item }}';
            const caseType = '${{ steps.extract_fields.outputs.case_type }}';
            const issue_number = '${{ steps.get_issue.outputs.issue_number }}';
            
            const commentBody = `## ❌ ServiceNow Case Creation Failed

            Failed to create case in ServiceNow.

            **Debug Information:**
            - **Catalog:** ${catalogItem}
            - **Case Type:** ${caseType}

            Check the [workflow logs](${context.payload.repository.html_url}/actions/runs/${context.runId}) for detailed error messages.

            ---
            *Contact support if the issue persists. Reference issue #${context.issue.number}*`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(issue_number),
              body: commentBody
            });